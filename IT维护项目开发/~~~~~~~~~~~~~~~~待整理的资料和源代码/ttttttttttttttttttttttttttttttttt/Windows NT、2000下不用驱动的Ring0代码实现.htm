<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0042)http://tzsvc.xiloo.com/doc/files/ring0.htm -->
<HTML><HEAD><TITLE>宗胜的编程乐园--文档 <http://tzsvc.xiloo.com></TITLE><!-- #BeginTemplate "/Templates/index3_old.dwt" --><!-- #BeginEditable "doctitle" --><!-- #EndEditable -->
<META http-equiv=Content-Type content="text/html; charset=gb2312">
<STYLE type=text/css>A {
	COLOR: #000000; TEXT-DECORATION: none
}
A:hover {
	TEXT-DECORATION: underline
}
</STYLE>

<SCRIPT language=JAVASCRIPT>
<!-- 
var timerID = null;
var timerRunning = false;
function stopclock (){
if(timerRunning)
clearTimeout(timerID);
timerRunning = false;
}
function showtime () {
var now = new Date();
var hours = now.getHours();
var minutes = now.getMinutes();
var seconds = now.getSeconds()
var timeValue = "现在时间是: " + ((hours >12) ? hours -12 :hours)
timeValue += ((minutes < 10) ? ":0" : ":") + minutes
timeValue += ((seconds < 10) ? ":0" : ":") + seconds
timeValue += (hours >= 12) ? " P.M." : " A.M."
window.status = timeValue;
timerID = setTimeout("showtime()",1000);
timerRunning = true;
}
function startclock () {
stopclock();
showtime();
}
-->
</SCRIPT>

<SCRIPT language=JavaScript>
<!--
function MM_reloadPage(init) {  //reloads the window if Nav4 resized
  if (init==true) with (navigator) {if ((appName=="Netscape")&&(parseInt(appVersion)==4)) {
    document.MM_pgW=innerWidth; document.MM_pgH=innerHeight; onresize=MM_reloadPage; }}
  else if (innerWidth!=document.MM_pgW || innerHeight!=document.MM_pgH) location.reload();
}
MM_reloadPage(true);
// -->
</SCRIPT>

<META content="MSHTML 5.50.4134.100" name=GENERATOR></HEAD>
<BODY text=#000000 bgColor=#ffffff leftMargin=0 onload=startclock()>
<TABLE cellSpacing=0 cellPadding=0 width=772 border=0>
  <TBODY>
  <TR>
    <TD vAlign=top align=left bgColor=#ffffff>
      <TABLE height=8 cellSpacing=0 cellPadding=0 width=776 align=center 
      border=0>
        <TBODY>
        <TR>
          <TD width=311 bgColor=#ffffff height=11><FONT color=#ffffff>　
            <SCRIPT language=JavaScript> <!---
today=new Date();
var hours = today.getHours();
var minutes = today.getMinutes();
var seconds = today.getSeconds();
var timeValue = "<FONT COLOR=black>" + ((hours >12) ? hours -12 :hours); timeValue += ((minutes < 10) ? "<BLINK><FONT COLOR=black>:</FONT></BLINK>0" : "<BLINK><FONT COLOR=black>:</FONT></BLINK>") + minutes+"</FONT></FONT>";
timeValue += (hours >= 12) ? "<FONT COLOR=blue><I><B>pm</B></I></FONT>" : "<FONT COLOR=blue><B><I>am</I></B></FONT>";
function initArray(){
this.length=initArray.arguments.length
for(var i=0;i<this.length;i++)
this[i+1]=initArray.arguments[i] }
var d=new initArray("<font color=RED>星期日","<font color=black>星期一","<font color=black>星期二","<font color=black>星期三","<font color=black>星期四","<font color=black>星期五","<font color=GREEN>星期六"); document.write("<font color=black>",today.getYear(),"<font color=red>年","<font color=black>",today.getMonth()+1,"<font color=red>月","<font color=black>",today.getDate(),"<font color=red>日 </FONT>",d[today.getDay()+1]," ",timeValue); //--></SCRIPT>
             <FONT color=#000000 size=2>登录</FONT></FONT></TD>
          <TD vAlign=bottom align=right width=51 bgColor=#ffffff height=11><A 
            href="http://tzsvc.xiloo.com/index.htm"><IMG height=17 
            src="Windows NT、2000下不用驱动的Ring0代码实现.files/head.jpg" width=51 
            border=0></A></TD>
          <TD vAlign=bottom align=middle width=36 bgColor=#e8ecf8 height=11><A 
            href="http://tzsvc.xiloo.com/mywriting/mywriting.htm"><FONT 
            color=#000000 size=2>作品</FONT></A></TD>
          <TD vAlign=bottom align=middle width=36 bgColor=#e8ecf8 
            height=11><FONT color=#000000 size=2><A 
            href="http://tzsvc.xiloo.com/firststu/firststu.htm">新手</A></FONT></TD>
          <TD vAlign=bottom align=middle width=36 bgColor=#e8ecf8 height=11><A 
            href="http://tzsvc.xiloo.com/doc/doc.htm"><FONT color=#000000 
            size=2>文章</FONT></A></TD>
          <TD vAlign=bottom align=middle width=36 bgColor=#e8ecf8 height=11><A 
            href="http://tzsvc.xiloo.com/skill/dll.htm"><FONT color=#000000 
            size=2>技巧</FONT></A></TD>
          <TD vAlign=bottom align=middle width=36 bgColor=#e8ecf8 height=11><A 
            href="http://tzsvc.xiloo.com/book/vc.htm"><FONT color=#000000 
            size=2>教程</FONT></A></TD>
          <TD vAlign=bottom align=middle width=36 bgColor=#e8ecf8 height=11><A 
            href="http://tzsvc.xiloo.com/code/code.htm"><FONT color=#000000 
            size=2>源码</FONT></A></TD>
          <TD vAlign=bottom align=middle width=36 bgColor=#e8ecf8 height=11><A 
            href="http://tzsvc.xiloo.com/ks/ks.htm"><FONT color=#000000 
            size=2>考试</FONT></A></TD>
          <TD vAlign=bottom align=middle width=36 bgColor=#e8ecf8 height=11><A 
            href="http://tzsvc.xiloo.com/job/job.htm"><FONT color=#000000 
            size=2>求职</FONT></A></TD>
          <TD vAlign=bottom align=middle width=36 bgColor=#e8ecf8 height=11><A 
            href="http://tzsvc.xiloo.com/download/download.htm"><FONT 
            color=#000000 size=2>下载</FONT></A></TD>
          <TD vAlign=bottom align=middle width=36 bgColor=#e8ecf8 height=11><A 
            href="http://tzsvc.xiloo.com/virus/virus.htm"><FONT color=#000000 
            size=2>病毒</FONT></A></TD>
          <TD vAlign=bottom align=left width=56 bgColor=#e8ecf8 height=11><A 
            href="http://tzsvc.xiloo.com/programmer/programmer.htm"><FONT 
            color=#000000 size=2>人生</FONT></A></TD></TR></TBODY></TABLE></TD></TR>
  <TR>
    <TD vAlign=top align=left bgColor=#0070b0></TD></TR>
  <TR vAlign=bottom align=left>
    <TD>
      <TABLE cellSpacing=0 cellPadding=0 width=761 align=center border=0>
        <TBODY>
        <TR>
          <TD width=188 height=49><IMG height=67 
            src="Windows NT、2000下不用驱动的Ring0代码实现.files/zititle.jpg" width=187></TD>
          <TD width=452 height=49><A 
            href="http://asiafriendfinder.com/go/f122344"><IMG height=67 src="" 
            width=450 align=absBottom border=0></A></TD>
          <TD width=121 height=49><FONT size=2><IFRAME border=0 
            src="Windows NT、2000下不用驱动的Ring0代码实现.files/showlink.htm" 
            frameBorder=0 width=120 scrolling=no 
        height=60></IFRAME></FONT></TD></TR></TBODY></TABLE></TD></TR>
  <TR bgColor=#0070b0>
    <TD><FONT color=#ffffff size=2><FONT size=2>　|<A target=_blank 
      href="http://www.sn163.net/cgi-bin/bbs3000/bbs.cgi?id=200205011106"><FONT 
      color=#ffffff size=2>编程论坛</FONT></A>|<A target=_blank 
      href="http://www.sn163.net/cgi-bin/gb2000/gb.cgi?id=tangzs"><FONT 
      color=#ffffff size=2>请您留言</FONT></A>|</FONT><A target=_blank 
      href="mailto:tzs168@yahoo.com.cn"><FONT color=#ffffff 
      size=2>联系我们</FONT></A>|</FONT></TD></TR>
  <TR>
    <TD vAlign=top align=left>
      <TABLE cellSpacing=0 cellPadding=0 width=777 border=0>
        <TBODY>
        <TR>
          <TD vAlign=top align=middle width=165 bgColor=#e8ecf8 
            height=104><IMG height=60 
            src="Windows NT、2000下不用驱动的Ring0代码实现.files/word.jpg" 
            width=140><BR><BR><FONT size=2><A 
            href="http://tzsvc.xiloo.com/other/new.htm">本站更新列表&gt;&gt;</A></FONT><BR><BR><FONT 
            size=2><A 
            href="http://tzsvc.xiloo.com/other/goodpage.htm">好站链接&gt;&gt;</A></FONT><BR></TD>
          <TD vAlign=top align=left width=12 height=104><IMG height=15 src="" 
            width=10></TD>
          <TD vAlign=top align=left width=600 height=104><!-- #BeginEditable "data" -->
            <TABLE height=64 cellSpacing=0 cellPadding=0 width=599 border=0>
              <TBODY>
              <TR>
                <TD><FONT 
                  size=2>日期:2002/5/28　　　　　　　　　　　　　　　　　　　　　　　　文章出处:csdn论坛</FONT></TD></TR>
              <TR>
                <TD><FONT size=2>标题:</FONT><FONT class=content><FONT 
                  color=#ff6600 size=2><B><FONT color=#000000>Windows 
                  NT/2000下不用驱动的Ring0代码实现</FONT></B></FONT></FONT></TD></TR>
              <TR>
                <TD>&nbsp;</TD></TR>
              <TR>
                <TD vAlign=top align=left>
                  <P><FONT class=content 
                  size=2><BR>WebCrazy(http://webcrazy.yeah.net/) </FONT></P>
                  <P><FONT size=2>大家知道，Windows 
                  NT/2000为实现其可靠性，严格将系统划分为内核模式与用户模式，<BR>在i386系统中分别对应CPU的Ring0与Ring3级别。Ring0下，可以执行特权级指令，对<BR>任何I/O设备都有访问权等等。要实现从用户态进入核心态，即从Ring 
                  3进入Ring 0必<BR>须借助CPU的某种门机制，如中断门、调用门等。而Windows 
                  NT/2000提供用户态执行系<BR>统服务(Ring 0例程)的此类机制即System Service的int 
                  2eh中断服务等，严格的参数<BR>检查，只能严格的执行Windows 
                  NT/2000提供的服务，而如果想执行用户提供的Ring 0<BR>代码(指运行在Ring 
                  0权限的代码)，常规方法似乎只有编写设备驱动程序。本文将介绍<BR>一种在用户态不借助任何驱动程序执行Ring0代码的方法。</FONT></P>
                  <P><FONT size=2>Windows 
                  NT/2000将设备驱动程序调入内核区域(常见的位于地址0x80000000上)，由DPL<BR>为0的GDT项8，即cs为8时实现Ring 
                  0权限。本文通过在系统中构造一个指向我们的代码<BR>的调用门(CallGate)，实现Ring0代码。基于这个思路，为实现这个目的主要是构造自己<BR>的CallGate。CallGate由系统中叫Global 
                  Descriptor 
                  Table(GDT)的全局表指定。GDT地<BR>址可由i386指令sgdt获得(sgdt不是特权级指令，普通Ring 
                  3程序均可执行)。GDT地址在<BR>Windows NT/2000保存于KPCR(Processor Control 
                  Region)结构中(见《再谈Windows 
                  NT/<BR>2000环境切换》)。GDT中的CallGate是如下的格式：</FONT></P>
                  <P><FONT size=2>typedef struct<BR>{<BR>unsigned short 
                  offset_0_15;<BR>unsigned short selector;</FONT></P>
                  <P><FONT size=2>unsigned char param_count : 4;<BR>unsigned 
                  char some_bits : 4;</FONT></P>
                  <P><FONT size=2>unsigned char type : 4;<BR>unsigned char 
                  app_system : 1;<BR>unsigned char dpl : 2;<BR>unsigned char 
                  present : 1;<BR><BR>unsigned short offset_16_31;<BR>} 
                  CALLGATE_DESCRIPTOR;</FONT></P>
                  <P><FONT 
                  size=2>GDT位于内核区域，一般用户态的程序是不可能对这段内存区域有直接的访问权。幸运的<BR>是Windows 
                  NT/2000提供了一个叫PhysicalMemory的Section内核对象位于\Device的路径<BR>下。顾名思义，通过这个Section对象可以对物理内存进行操作。用objdir.exe对这个对<BR>象分析如下：</FONT></P>
                  <P><FONT size=2>C:\NTDDK\bin&gt;objdir /D \Device</FONT></P>
                  <P><FONT size=2>PhysicalMemory <BR>Section<BR>DACL - <BR>Ace[ 
                  0] - Grant - 0xf001f - NT AUTHORITY\SYSTEM<BR>Inherit: 
                  <BR>Access: 0x001F and ( D RCtl WOwn WDacl )</FONT></P>
                  <P><FONT size=2>Ace[ 1] - Grant - 0x2000d - 
                  BUILTIN\Administrators<BR>Inherit: <BR>Access: 0x000D and ( 
                  RCtl )</FONT></P>
                  <P><FONT 
                  size=2>从dump出的这个对象DACL的Ace可以看出默认情况下只有SYSTEM用户才有对这个对象的读写<BR>权限，即对物理内存有读写能力，而Administrator只有读权限，普通用户根本就没有权限。<BR>不过如果我们有Administrator权限就可以通过GetSecurityInfo、SetEntriesInAcl与Set<BR>SecurityInfo这些API来修改这个对象的ACE。这也是我提供的代码需要Administrator的原<BR>因。实现的代码如下：</FONT></P>
                  <P><FONT size=2>VOID 
                  SetPhyscialMemorySectionCanBeWrited(HANDLE 
                  hSection)<BR>{</FONT></P>
                  <P><FONT size=2>PACL pDacl=NULL;<BR>PACL 
                  pNewDacl=NULL;<BR>PSECURITY_DESCRIPTOR pSD=NULL;<BR>DWORD 
                  dwRes;<BR>EXPLICIT_ACCESS ea;</FONT></P>
                  <P><FONT 
                  size=2>if(dwRes=GetSecurityInfo(hSection,SE_KERNEL_OBJECT,DACL_SECURITY_INFORMATION,<BR>NULL,NULL,&amp;pDacl,NULL,&amp;pSD)!=ERROR_SUCCESS)<BR>{<BR>printf( 
                  "GetSecurityInfo Error %u\n", dwRes );<BR>goto 
                  CleanUp;<BR>}</FONT></P>
                  <P><FONT size=2>ZeroMemory(&amp;ea, 
                  sizeof(EXPLICIT_ACCESS));<BR>ea.grfAccessPermissions = 
                  SECTION_MAP_WRITE;<BR>ea.grfAccessMode = 
                  GRANT_ACCESS;<BR>ea.grfInheritance= 
                  NO_INHERITANCE;<BR>ea.Trustee.TrusteeForm = 
                  TRUSTEE_IS_NAME;<BR>ea.Trustee.TrusteeType = 
                  TRUSTEE_IS_USER;<BR>ea.Trustee.ptstrName = 
                  "CURRENT_USER";</FONT></P>
                  <P><FONT 
                  size=2><BR>if(dwRes=SetEntriesInAcl(1,&amp;ea,pDacl,&amp;pNewDacl)!=ERROR_SUCCESS)<BR>{<BR>printf( 
                  "SetEntriesInAcl %u\n", dwRes );<BR>goto 
                  CleanUp;<BR>}</FONT></P>
                  <P><FONT 
                  size=2>if(dwRes=SetSecurityInfo(hSection,SE_KERNEL_OBJECT,DACL_SECURITY_INFORMATION,<BR>NULL,NULL,pNewDacl,NULL)!=ERROR_SUCCESS)<BR>{<BR>printf("SetSecurityInfo 
                  %u\n",dwRes);<BR>goto CleanUp;<BR>}</FONT></P>
                  <P><FONT size=2>CleanUp:</FONT></P>
                  <P><FONT 
                  size=2>if(pSD)<BR>LocalFree(pSD);<BR>if(pNewDacl)<BR>LocalFree(pSD);<BR>}</FONT></P>
                  <P><FONT size=2>这段代码对给定HANDLE的对象增加了如下的ACE: </FONT></P>
                  <P><FONT size=2>PhysicalMemory <BR>Section<BR>DACL - <BR>Ace[ 
                  0] - Grant - 0x2 - WEBCRAZY\Administrator<BR>Inherit: 
                  <BR>Access: 0x0002 //SECTION_MAP_WRITE</FONT></P>
                  <P><FONT 
                  size=2>这样我们在有Administrator权限的条件下就有了对物理内存的读写能力。但若要修改GDT<BR>表实现Ring 
                  0代码。我们将面临着另一个难题，因为sgdt指令获得的GDT地址是虚拟地址<BR>(线性地址)，我们只有知道GDT表的物理地址后才能通过\Device\PhysicalMemory对象修<BR>改GDT表，这就牵涉到了线性地址转化成物理地址的问题。我们先来看一看Windows 
                  NT/<BR>2000是如何实现这个的：</FONT></P>
                  <P><FONT size=2>kd&gt; u nt!MmGetPhysicalAddress l 
                  30<BR>ntoskrnl!MmGetPhysicalAddress:<BR>801374e0 56 push 
                  esi<BR>801374e1 8b742408 mov esi,[esp+0x8]<BR>801374e5 33d2 
                  xor edx,edx<BR>801374e7 81fe00000080 cmp 
                  esi,0x80000000<BR>801374ed 722c jb 
                  ntoskrnl!MmGetPhysicalAddress+0x2b (8013751b)<BR>801374ef 
                  81fe000000a0 cmp esi,0xa0000000<BR>801374f5 7324 jnb 
                  ntoskrnl!MmGetPhysicalAddress+0x2b (8013751b)<BR>801374f7 
                  39153ce71780 cmp [ntoskrnl!MmKseg2Frame 
                  (8017e73c)],edx<BR>801374fd 741c jz 
                  ntoskrnl!MmGetPhysicalAddress+0x2b (8013751b)<BR>801374ff 8bc6 
                  mov eax,esi<BR>80137501 c1e80c shr eax,0xc<BR>80137504 
                  25ffff0100 and eax,0x1ffff<BR>80137509 6a0c push 
                  0xc<BR>8013750b 59 pop ecx<BR>8013750c e8d3a7fcff call 
                  ntoskrnl!_allshl (80101ce4)<BR>80137511 81e6ff0f0000 and 
                  esi,0xfff<BR>80137517 03c6 add eax,esi<BR>80137519 eb17 jmp 
                  ntoskrnl!MmGetPhysicalAddress+0x57 (80137532)<BR>8013751b 8bc6 
                  mov eax,esi<BR>8013751d c1e80a shr eax,0xa<BR>80137520 
                  25fcff3f00 and eax,0x3ffffc<BR>80137525 2d00000040 sub 
                  eax,0x40000000<BR>8013752a 8b00 mov eax,[eax]<BR>8013752c a801 
                  test al,0x1<BR>8013752e 7506 jnz 
                  ntoskrnl!MmGetPhysicalAddress+0x44 (80137536)<BR>80137530 33c0 
                  xor eax,eax<BR>80137532 5e pop esi<BR>80137533 c20400 ret 
                  0x4</FONT></P>
                  <P><FONT 
                  size=2>从这段汇编代码可看出如果线性地址在0x80000000与0xa0000000范围内，只是简单的进行<BR>移位操作(位于801374ff-80137519指令间)，并未查页表。我想Microsoft这样安排肯定是<BR>出于执行效率的考虑。这也为我们指明了一线曙光，因为GDT表在Windows 
                  NT/2000中一般<BR>情况下均位于这个区域(我不知道/3GB开关的Windows 
                  NT/2000是不是这种情况)。</FONT></P>
                  <P><FONT 
                  size=2>经过这样的分析，我们就可以只通过用户态程序修改GDT表了。而增加一个CallGate就不是<BR>我可以介绍的了，找本Intel手册自己看一看了。具体实现代码如下：</FONT></P>
                  <P><FONT size=2>typedef struct gdtr {<BR>short Limit;<BR>short 
                  BaseLow;<BR>short BaseHigh;<BR>} Gdtr_t, *PGdtr_t;</FONT></P>
                  <P><FONT size=2>ULONG MiniMmGetPhysicalAddress(ULONG 
                  virtualaddress)<BR>{<BR>if(virtualaddress&lt;0x80000000||virtualaddress&gt;=0xA0000000)<BR>return 
                  0;<BR>return virtualaddress&amp;0x1FFFF000;<BR>}</FONT></P>
                  <P><FONT size=2>BOOL ExecRing0Proc(ULONG Entry,ULONG 
                  seglen)<BR>{<BR>Gdtr_t gdt;<BR>__asm sgdt gdt;<BR><BR>ULONG 
                  mapAddr=MiniMmGetPhysicalAddress(gdt.BaseHigh&lt;&lt;16U|gdt.BaseLow);<BR>if(!mapAddr) 
                  return 0;</FONT></P>
                  <P><FONT size=2>HANDLE hSection=NULL;<BR>NTSTATUS 
                  status;<BR>OBJECT_ATTRIBUTES 
                  objectAttributes;<BR>UNICODE_STRING 
                  objName;<BR>CALLGATE_DESCRIPTOR *cg;</FONT></P>
                  <P><FONT size=2>status = 
                  STATUS_SUCCESS;<BR><BR>RtlInitUnicodeString(&amp;objName,L"\\Device\\PhysicalMemory");</FONT></P>
                  <P><FONT 
                  size=2>InitializeObjectAttributes(&amp;objectAttributes,<BR>&amp;objName,<BR>OBJ_CASE_INSENSITIVE 
                  | OBJ_KERNEL_HANDLE,<BR>NULL,<BR>(PSECURITY_DESCRIPTOR) 
                  NULL);</FONT></P>
                  <P><FONT size=2>status = 
                  ZwOpenSection(&amp;hSection,SECTION_MAP_READ|SECTION_MAP_WRITE,<BR>&amp;objectAttributes);</FONT></P>
                  <P><FONT size=2>if(status == STATUS_ACCESS_DENIED){<BR>status 
                  = 
                  ZwOpenSection(&amp;hSection,READ_CONTROL|WRITE_DAC<BR>　　　　　　　　　　　,&amp;objectAttributes);<BR>SetPhyscialMemorySectionCanBeWrited(hSection);<BR>ZwClose(hSection);<BR>status 
                  =ZwOpenSection(&amp;hSection,SECTION_MAP_WRITE|SECTION_MAP_WRITE,<BR>　　　　　　　　&amp;objectAttributes);<BR>}</FONT></P>
                  <P><FONT size=2>if(status != 
                  STATUS_SUCCESS)<BR>{<BR>printf("Error Open PhysicalMemory 
                  Section Object,Status:%08X\n",status);<BR>return 
                  0;<BR>}<BR><BR>PVOID BaseAddress;</FONT></P>
                  <P><FONT 
                  size=2>BaseAddress=MapViewOfFile(hSection,<BR>FILE_MAP_READ|FILE_MAP_WRITE,<BR>0,<BR>mapAddr, 
                  //low part<BR>(gdt.Limit+1));</FONT></P>
                  <P><FONT size=2>if(!BaseAddress)<BR>{<BR>printf("Error 
                  MapViewOfFile:");<BR>PrintWin32Error(GetLastError());<BR>return 
                  0;<BR>}</FONT></P>
                  <P><FONT size=2>BOOL setcg=FALSE;</FONT></P>
                  <P><FONT size=2>for(cg=(CALLGATE_DESCRIPTOR 
                  *)((ULONG)BaseAddress+(gdt.Limit&amp;0xFFF8));<BR>　　　　　　　　　　　　　　(ULONG)cg&gt;(ULONG)BaseAddress;cg--)<BR>if(cg-&gt;type 
                  == 0){<BR>cg-&gt;offset_0_15 = 
                  LOWORD(Entry);<BR>cg-&gt;selector = 8;<BR>cg-&gt;param_count = 
                  0;<BR>cg-&gt;some_bits = 0;<BR>cg-&gt;type = 0xC; // 386 call 
                  gate<BR>cg-&gt;app_system = 0; // A system 
                  descriptor<BR>cg-&gt;dpl = 3; // Ring 3 code can 
                  call<BR>cg-&gt;present = 1;<BR>cg-&gt;offset_16_31 = 
                  HIWORD(Entry);<BR>setcg=TRUE;<BR>break;<BR>}</FONT></P>
                  <P><FONT size=2>if(!setcg){<BR>ZwClose(hSection);<BR>return 
                  0;<BR>}</FONT></P>
                  <P><FONT size=2>short farcall[3];</FONT></P>
                  <P><FONT 
                  size=2>farcall[2]=((short)((ULONG)cg-(ULONG)BaseAddress))|3; 
                  //Ring 3 callgate;</FONT></P>
                  <P><FONT 
                  size=2>if(!VirtualLock((PVOID)Entry,seglen))<BR>{<BR>printf("Error 
                  VirtualLock:");<BR>PrintWin32Error(GetLastError());<BR>return 
                  0;<BR>}</FONT></P>
                  <P><FONT 
                  size=2>SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_TIME_CRITICAL);</FONT></P>
                  <P><FONT size=2>Sleep(0);</FONT></P>
                  <P><FONT size=2>_asm call fword ptr [farcall]</FONT></P>
                  <P><FONT 
                  size=2>SetThreadPriority(GetCurrentThread(),THREAD_PRIORITY_NORMAL);</FONT></P>
                  <P><FONT size=2>VirtualUnlock((PVOID)Entry,seglen);</FONT></P>
                  <P><FONT size=2>//Clear callgate<BR>*(ULONG 
                  *)cg=0;<BR>*((ULONG *)cg+1)=0;</FONT></P>
                  <P><FONT size=2>ZwClose(hSection);<BR>return TRUE;</FONT></P>
                  <P><FONT size=2>}</FONT></P>
                  <P><FONT size=2>我在提供的代码中演示了对Control 
                  Register与I/O端口的操作。CIH病毒在Windows <BR>9X中就是因为获得Ring 
                  0权限才有了一定的危害，但Windows NT/2000毕竟不是Windo<BR>ws 
                  9X，她已经有了比较多的安全审核机制，本文提供的代码也要求具有Administra<BR>tor权限，但如果系统存在某种漏洞，如缓冲区溢出等等，还是有可能获得这种权限的，<BR>所以我不对本文提供的方法负有任何的责任，所有讨论只是一个技术热爱者在讨论<BR>技术而已。谢谢！ 
                  </FONT></P>
                  <P><FONT size=2>参考资料：<BR>1.Intel Corp&lt;&lt;Intel 
                  Architecture Software Developer's Manual,Volume 
                  3&gt;&gt;</FONT></P>
                  <P><FONT size=2></FONT></P></TD></TR>
              <TR>
                <TD align=middle><FONT size=2>上一页 第0页 下一页</FONT></TD></TR>
              <TR>
                <TD align=middle><FONT size=2><INPUT onclick=history.go(-1) type=button value=后退 name=button> 
<INPUT onclick=history.go(1) type=button value=前进 name=button2> 
<INPUT onclick=window.close() type=button value=关闭 name=button3> 
                  </FONT></TD></TR></TBODY></TABLE><!-- #EndEditable --></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<TABLE cellSpacing=0 cellPadding=0 width=764 align=center border=0>
  <TBODY>
  <TR>
    <TD>
      <HR SIZE=1>
    </TD></TR>
  <TR>
    <TD align=middle><FONT size=2>Copyright(C)2002 
      宗胜的编程乐园　http://tzsvc.xiloo.com <BR>文章版权归原作者所有，如仍有问题，请与我联系 </FONT></TD></TR>
  <TR>
    <TD>
      <HR SIZE=1>
    </TD></TR></TBODY></TABLE><!-- #EndTemplate --></BODY></HTML>
