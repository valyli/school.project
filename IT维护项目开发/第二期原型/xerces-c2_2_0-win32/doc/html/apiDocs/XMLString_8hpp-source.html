<HTML><HEAD><SCRIPT language="JavaScript" src="../resources/script.js" type="text/javascript"></SCRIPT><TITLE>XMLString.hpp Source File</TITLE><link href="XercesApi.css" rel="stylesheet" type="text/css"></HEAD><BODY alink="#ff0000" bgcolor="#ffffff" leftmargin="4" link="#0000ff" marginheight="4" marginwidth="4" text="#000000" topmargin="4" vlink="#0000aa"><TABLE border="0" cellpadding="0" cellspacing="0" width="620"><TR><TD align="left" height="60" rowspan="3" valign="top" width="135"><IMG border="0" height="60" hspace="0" src="../resources/logo.gif" vspace="0" width="135"></TD><TD align="left" colspan="4" height="5" valign="top" width="456"><IMG border="0" height="5" hspace="0" src="../resources/line.gif" vspace="0" width="456"></TD><TD align="left" height="60" rowspan="3" valign="top" width="29"><IMG border="0" height="60" hspace="0" src="../resources/right.gif" vspace="0" width="29"></TD></TR><TR><TD align="left" bgcolor="#0086b2" colspan="4" height="35" valign="top" width="456"><IMG alt="" border="0" height="35" hspace="0" src="../graphics/api-header.jpg" vspace="0" width="456"></TD></TR><TR><TD align="left" height="20" valign="top" width="168"><IMG border="0" height="20" hspace="0" src="../resources/bottom.gif" vspace="0" width="168"></TD><TD align="left" height="20" valign="top" width="96"><A href="http://xml.apache.org/" onMouseOut="rolloverOff('xml');" onMouseOver="rolloverOn('xml');" target="new"><IMG alt="http://xml.apache.org/" border="0" height="20" hspace="0" name="xml" onLoad="rolloverLoad('xml','../resources/button-xml-hi.gif','../resources/button-xml-lo.gif');" src="../resources/button-xml-lo.gif" vspace="0" width="96"></A></TD><TD align="left" height="20" valign="top" width="96"><A href="http://www.apache.org/" onMouseOut="rolloverOff('asf');" onMouseOver="rolloverOn('asf');" target="new"><IMG alt="http://www.apache.org/" border="0" height="20" hspace="0" name="asf" onLoad="rolloverLoad('asf','../resources/button-asf-hi.gif','../resources/button-asf-lo.gif');" src="../resources/button-asf-lo.gif" vspace="0" width="96"></A></TD><TD align="left" height="20" valign="top" width="96"><A href="http://www.w3.org/" onMouseOut="rolloverOff('w3c');" onMouseOver="rolloverOn('w3c');" target="new"><IMG alt="http://www.w3.org/" border="0" height="20" hspace="0" name="w3c" onLoad="rolloverLoad('w3c','../resources/button-w3c-hi.gif','../resources/button-w3c-lo.gif');" src="../resources/button-w3c-lo.gif" vspace="0" width="96"></A></TD></TR></TABLE><TABLE border="0" cellpadding="0" cellspacing="0" width="620"><TR><TD align="left" valign="top" width="120"><IMG border="0" height="14" hspace="0" src="../resources/join.gif" vspace="0" width="120"><BR>
  <A href="../../index.html" onMouseOut="rolloverOff('side-ext-2');" onMouseOver="rolloverOn('side-ext-2');"><IMG alt="Home" border="0" height="12" hspace="0" name="side-ext-2" onLoad="rolloverLoad('side-ext-2','../graphics/ext-2-label-2.jpg','../graphics/ext-2-label-3.jpg');" src="../graphics/ext-2-label-3.jpg" vspace="0" width="120"></A><BR>

  <IMG border="0" height="6" hspace="0" src="../resources/separator.gif" vspace="0" width="120"><BR>

  <A href="../index.html" onMouseOut="rolloverOff('side-index');" onMouseOver="rolloverOn('side-index');"><IMG alt="Readme" border="0" height="12" hspace="0" name="side-index" onLoad="rolloverLoad('side-index','../graphics/index-label-2.jpg','../graphics/index-label-3.jpg');" src="../graphics/index-label-3.jpg" vspace="0" width="120"></A><BR>
  <A href="../releases.html" onMouseOut="rolloverOff('side-releases');" onMouseOver="rolloverOn('side-releases');"><IMG alt="Release Info" border="0" height="12" hspace="0" name="side-releases" onLoad="rolloverLoad('side-releases','../graphics/releases-label-2.jpg','../graphics/releases-label-3.jpg');" src="../graphics/releases-label-3.jpg" vspace="0" width="120"></A><BR>
  <IMG border="0" height="6" hspace="0" src="../resources/separator.gif" vspace="0" width="120"><BR>
  <A href="../install.html" onMouseOut="rolloverOff('side-install');" onMouseOver="rolloverOn('side-install');"><IMG alt="Installation" border="0" height="12" hspace="0" name="side-install" onLoad="rolloverLoad('side-install','../graphics/install-label-2.jpg','../graphics/install-label-3.jpg');" src="../graphics/install-label-3.jpg" vspace="0" width="120"></A><BR>
  <A href="http://xml.apache.org/dist/xerces-c/" onMouseOut="rolloverOff('side-ext-18');" onMouseOver="rolloverOn('side-ext-18');"><IMG alt="Download" border="0" height="12" hspace="0" name="side-ext-18" onLoad="rolloverLoad('side-ext-18','../graphics/ext-18-label-2.jpg','../graphics/ext-18-label-3.jpg');" src="../graphics/ext-18-label-3.jpg" vspace="0" width="120"></A><BR>
  <A href="../build.html" onMouseOut="rolloverOff('side-build');" onMouseOver="rolloverOn('side-build');"><IMG alt="Build" border="0" height="12" hspace="0" name="side-build" onLoad="rolloverLoad('side-build','../graphics/build-label-2.jpg','../graphics/build-label-3.jpg');" src="../graphics/build-label-3.jpg" vspace="0" width="120"></A><BR>

  <IMG border="0" height="6" hspace="0" src="../resources/separator.gif" vspace="0" width="120"><BR>
  <A href="../faqs.html" onMouseOut="rolloverOff('side-faqs');" onMouseOver="rolloverOn('side-faqs');"><IMG alt="FAQs" border="0" height="12" hspace="0" name="side-faqs" onLoad="rolloverLoad('side-faqs','../graphics/faqs-label-2.jpg','../graphics/faqs-label-3.jpg');" src="../graphics/faqs-label-3.jpg" vspace="0" width="120"></A><BR>  
  <A href="../samples.html" onMouseOut="rolloverOff('side-samples');" onMouseOver="rolloverOn('side-samples');"><IMG alt="Samples" border="0" height="12" hspace="0" name="side-samples" onLoad="rolloverLoad('side-samples','../graphics/samples-label-2.jpg','../graphics/samples-label-3.jpg');" src="../graphics/samples-label-3.jpg" vspace="0" width="120"></A><BR>
  <A href="../api.html" onMouseOut="rolloverOff('side-api');" onMouseOver="rolloverOn('side-api');"><IMG alt="API Docs" border="0" height="12" hspace="0" name="side-api" onLoad="rolloverLoad('side-api','../graphics/api-label-2.jpg','../graphics/api-label-3.jpg');" src="../graphics/api-label-3.jpg" vspace="0" width="120"></A><BR>  

  <IMG border="0" height="6" hspace="0" src="../resources/separator.gif" vspace="0" width="120"><BR>
  <A href="../ApacheDOMC++Binding.html" onMouseOut="rolloverOff('side-ext-64');" onMouseOver="rolloverOn('side-ext-64');"><IMG alt="DOM C++ Binding" border="0" height="12" hspace="0" name="side-ext-64" onLoad="rolloverLoad('side-ext-64','../graphics/ext-64-label-2.jpg','../graphics/ext-64-label-3.jpg');" src="../graphics/ext-64-label-3.jpg" vspace="0" width="120"></A><BR> 
  <A href="../program.html" onMouseOut="rolloverOff('side-program');" onMouseOver="rolloverOn('side-program');"><IMG alt="Programming" border="0" height="12" hspace="0" name="side-program" onLoad="rolloverLoad('side-program','../graphics/program-label-2.jpg','../graphics/program-label-3.jpg');" src="../graphics/program-label-3.jpg" vspace="0" width="120"></A><BR>
  <A href="../migrate.html" onMouseOut="rolloverOff('side-migrate');" onMouseOver="rolloverOn('side-migrate');"><IMG alt="Migration Guide" border="0" height="12" hspace="0" name="side-migrate" onLoad="rolloverLoad('side-migrate','../graphics/migrate-label-2.jpg','../graphics/migrate-label-3.jpg');" src="../graphics/migrate-label-3.jpg" vspace="0" width="120"></A><BR>

  <IMG border="0" height="6" hspace="0" src="../resources/separator.gif" vspace="0" width="120"><BR>

  <A href="../feedback.html" onMouseOut="rolloverOff('side-feedback');" onMouseOver="rolloverOn('side-feedback');"><IMG alt="Feedback" border="0" height="12" hspace="0" name="side-feedback" onLoad="rolloverLoad('side-feedback','../graphics/feedback-label-2.jpg','../graphics/feedback-label-3.jpg');" src="../graphics/feedback-label-3.jpg" vspace="0" width="120"></A><BR>
  <A href="../bug-report.html" onMouseOut="rolloverOff('side-bug-report');" onMouseOver="rolloverOn('side-bug-report');"><IMG alt="Bug-Reporting" border="0" height="12" hspace="0" name="side-bug-report" onLoad="rolloverLoad('side-bug-report','../graphics/bug-report-label-2.jpg','../graphics/bug-report-label-3.jpg');" src="../graphics/bug-report-label-3.jpg" vspace="0" width="120"></A><BR>  
  <A href="../pdf.html" onMouseOut="rolloverOff('side-pdf');" onMouseOver="rolloverOn('side-pdf');"><IMG alt="PDF Document" border="0" height="12" hspace="0" name="side-pdf" onLoad="rolloverLoad('side-pdf','../graphics/pdf-label-2.jpg','../graphics/pdf-label-3.jpg');" src="../graphics/pdf-label-3.jpg" vspace="0" width="120"></A><BR>

  <IMG border="0" height="6" hspace="0" src="../resources/separator.gif" vspace="0" width="120"><BR>

  <A href="http://xml.apache.org/websrc/cvsweb.cgi/xml-xerces/c/" onMouseOut="rolloverOff('side-ext-96');" onMouseOver="rolloverOn('side-ext-96');"><IMG alt="CVS Repository" border="0" height="12" hspace="0" name="side-ext-96" onLoad="rolloverLoad('side-ext-96','../graphics/ext-96-label-2.jpg','../graphics/ext-96-label-3.jpg');" src="../graphics/ext-96-label-3.jpg" vspace="0" width="120"></A><BR>
  <A href="http://marc.theaimsgroup.com/?l=xerces-c-dev" onMouseOut="rolloverOff('side-ext-98');" onMouseOver="rolloverOn('side-ext-98');"><IMG alt="Mail Archive" border="0" height="12" hspace="0" name="side-ext-98" onLoad="rolloverLoad('side-ext-98','../graphics/ext-98-label-2.jpg','../graphics/ext-98-label-3.jpg');" src="../graphics/ext-98-label-3.jpg" vspace="0" width="120"></A><BR>

<IMG border="0" height="14" hspace="0" src="../resources/close.gif" vspace="0" width="120"><BR></TD><TD align="left" valign="top" width="500"><TABLE border="0" cellpadding="3" cellspacing="0"><TR><TD>
    <TABLE border="0" cellpadding="0" cellspacing="0" width="494"><TR><TD bgcolor="#FFFFFF" colspan="2" width="494"><TABLE border="0" cellpadding="0" cellspacing="0" width="494"><TR><TD bgcolor="#039acc" height="1" width="1"><IMG border="0" height="1" hspace="0" src="../resources/void.gif" vspace="0" width="1"></TD><TD bgcolor="#039acc" height="1" width="492"><IMG border="0" height="1" hspace="0" src="../resources/void.gif" vspace="0" width="492"></TD><TD bgcolor="#0086b2" height="1" width="1"><IMG border="0" height="1" hspace="0" src="../resources/void.gif" vspace="0" width="1"></TD></TR><TR><TD bgcolor="#039acc" width="1"><IMG border="0" height="1" hspace="0" src="../resources/void.gif" vspace="0" width="1"></TD><TD bgcolor="#0086b2" width="492"><FONT color="#ffffff" face="arial,helvetica,sanserif" size="+1"><IMG border="0" height="2" hspace="0" src="../resources/void.gif" vspace="0" width="2"><B>API Docs for SAX and DOM</B></FONT></TD><TD bgcolor="#017299" width="1"><IMG border="0" height="1" hspace="0" src="../resources/void.gif" vspace="0" width="1"></TD></TR><TR><TD bgcolor="#0086b2" height="1" width="1"><IMG border="0" height="1" hspace="0" src="../resources/void.gif" vspace="0" width="1"></TD><TD bgcolor="#017299" height="1" width="492"><IMG border="0" height="1" hspace="0" src="../resources/void.gif" vspace="0" width="492"></TD><TD bgcolor="#017299" height="1" width="1"><IMG border="0" height="1" hspace="0" src="../resources/void.gif" vspace="0" width="1"></TD></TR></TABLE></TD></TR><TR><TD width="10">&nbsp;</TD><TD width="484"><FONT color="#000000" face="arial,helvetica,sanserif">

	    <P>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="classes.html">Alphabetical List</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; <a class="qindex" href="globals.html">File Members</a> &nbsp; </center>
<hr><h1>XMLString.hpp</h1><a href="XMLString_8hpp.html">Go to the documentation of this file.</a><div class="fragment"><pre>00001 <span class="comment">/*</span>
00002 <span class="comment"> * The Apache Software License, Version 1.1</span>
00003 <span class="comment"> *</span>
00004 <span class="comment"> * Copyright (c) 1999-2001 The Apache Software Foundation.  All rights</span>
00005 <span class="comment"> * reserved.</span>
00006 <span class="comment"> *</span>
00007 <span class="comment"> * Redistribution and use in source and binary forms, with or without</span>
00008 <span class="comment"> * modification, are permitted provided that the following conditions</span>
00009 <span class="comment"> * are met:</span>
00010 <span class="comment"> *</span>
00011 <span class="comment"> * 1. Redistributions of source code must retain the above copyright</span>
00012 <span class="comment"> *    notice, this list of conditions and the following disclaimer.</span>
00013 <span class="comment"> *</span>
00014 <span class="comment"> * 2. Redistributions in binary form must reproduce the above copyright</span>
00015 <span class="comment"> *    notice, this list of conditions and the following disclaimer in</span>
00016 <span class="comment"> *    the documentation and/or other materials provided with the</span>
00017 <span class="comment"> *    distribution.</span>
00018 <span class="comment"> *</span>
00019 <span class="comment"> * 3. The end-user documentation included with the redistribution,</span>
00020 <span class="comment"> *    if any, must include the following acknowledgment:</span>
00021 <span class="comment"> *       "This product includes software developed by the</span>
00022 <span class="comment"> *        Apache Software Foundation (http://www.apache.org/)."</span>
00023 <span class="comment"> *    Alternately, this acknowledgment may appear in the software itself,</span>
00024 <span class="comment"> *    if and wherever such third-party acknowledgments normally appear.</span>
00025 <span class="comment"> *</span>
00026 <span class="comment"> * 4. The names "Xerces" and "Apache Software Foundation" must</span>
00027 <span class="comment"> *    not be used to endorse or promote products derived from this</span>
00028 <span class="comment"> *    software without prior written permission. For written</span>
00029 <span class="comment"> *    permission, please contact apache\@apache.org.</span>
00030 <span class="comment"> *</span>
00031 <span class="comment"> * 5. Products derived from this software may not be called "Apache",</span>
00032 <span class="comment"> *    nor may "Apache" appear in their name, without prior written</span>
00033 <span class="comment"> *    permission of the Apache Software Foundation.</span>
00034 <span class="comment"> *</span>
00035 <span class="comment"> * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED</span>
00036 <span class="comment"> * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES</span>
00037 <span class="comment"> * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
00038 <span class="comment"> * DISCLAIMED.  IN NO EVENT SHALL THE APACHE SOFTWARE FOUNDATION OR</span>
00039 <span class="comment"> * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</span>
00040 <span class="comment"> * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT</span>
00041 <span class="comment"> * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF</span>
00042 <span class="comment"> * USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND</span>
00043 <span class="comment"> * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
00044 <span class="comment"> * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT</span>
00045 <span class="comment"> * OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF</span>
00046 <span class="comment"> * SUCH DAMAGE.</span>
00047 <span class="comment"> * ====================================================================</span>
00048 <span class="comment"> *</span>
00049 <span class="comment"> * This software consists of voluntary contributions made by many</span>
00050 <span class="comment"> * individuals on behalf of the Apache Software Foundation, and was</span>
00051 <span class="comment"> * originally based on software copyright (c) 1999, International</span>
00052 <span class="comment"> * Business Machines, Inc., http://www.ibm.com .  For more information</span>
00053 <span class="comment"> * on the Apache Software Foundation, please see</span>
00054 <span class="comment"> * &lt;http://www.apache.org/&gt;.</span>
00055 <span class="comment"> */</span>
00056 
00057 <span class="comment">/*</span>
00058 <span class="comment"> * $Log: XMLString.hpp,v $</span>
00059 <span class="comment"> * Revision 1.13  2003/02/05 18:50:56  tng</span>
00060 <span class="comment"> * [Bug 11915] Utility for freeing memory.</span>
00061 <span class="comment"> *</span>
00062 <span class="comment"> * Revision 1.12  2003/01/24 23:16:33  peiyongz</span>
00063 <span class="comment"> * removeWS() added;</span>
00064 <span class="comment"> *</span>
00065 <span class="comment"> * Revision 1.11  2002/12/20 22:10:21  tng</span>
00066 <span class="comment"> * XML 1.1</span>
00067 <span class="comment"> *</span>
00068 <span class="comment"> * Revision 1.10  2002/12/18 14:17:54  gareth</span>
00069 <span class="comment"> * Fix to bug #13438. When you eant a vector that calls delete[] on its members you should use RefArrayVectorOf.</span>
00070 <span class="comment"> *</span>
00071 <span class="comment"> * Revision 1.9  2002/12/04 02:32:43  knoaman</span>
00072 <span class="comment"> * #include cleanup.</span>
00073 <span class="comment"> *</span>
00074 <span class="comment"> * Revision 1.8  2002/11/05 17:42:39  peiyongz</span>
00075 <span class="comment"> * equals( const char* const, const char* const)</span>
00076 <span class="comment"> *</span>
00077 <span class="comment"> * Revision 1.7  2002/11/04 15:22:05  tng</span>
00078 <span class="comment"> * C++ Namespace Support.</span>
00079 <span class="comment"> *</span>
00080 <span class="comment"> * Revision 1.6  2002/10/01 19:45:22  tng</span>
00081 <span class="comment"> * Performance in XMLString::equals, only need to check one string for null as they are equal already.</span>
00082 <span class="comment"> *</span>
00083 <span class="comment"> * Revision 1.5  2002/09/24 19:41:21  tng</span>
00084 <span class="comment"> * New inline function equals that is modified from compareString but simply return true or false.</span>
00085 <span class="comment"> *</span>
00086 <span class="comment"> * Revision 1.4  2002/09/23 18:42:18  tng</span>
00087 <span class="comment"> * DOM L3: Support baseURI.   Add utility fixURI to transform an absolute path filename to standard URI form.</span>
00088 <span class="comment"> *</span>
00089 <span class="comment"> * Revision 1.3  2002/08/27 19:24:43  peiyongz</span>
00090 <span class="comment"> * Bug#12087: patch from Thomas Ford (tom@decisionsoft.com)</span>
00091 <span class="comment"> *</span>
00092 <span class="comment"> * Revision 1.2  2002/02/20 18:17:02  tng</span>
00093 <span class="comment"> * [Bug 5977] Warnings on generating apiDocs.</span>
00094 <span class="comment"> *</span>
00095 <span class="comment"> * Revision 1.1.1.1  2002/02/01 22:22:16  peiyongz</span>
00096 <span class="comment"> * sane_include</span>
00097 <span class="comment"> *</span>
00098 <span class="comment"> * Revision 1.26  2001/08/10 16:23:06  peiyongz</span>
00099 <span class="comment"> * isHex(), isAlphaNum(), isAllWhiteSpace() and patternMatch() Added</span>
00100 <span class="comment"> *</span>
00101 <span class="comment"> * Revision 1.25  2001/07/06 20:27:57  peiyongz</span>
00102 <span class="comment"> * isValidaQName()</span>
00103 <span class="comment"> *</span>
00104 <span class="comment"> * Revision 1.24  2001/07/04 14:38:20  peiyongz</span>
00105 <span class="comment"> * IDDatatypeValidator: created</span>
00106 <span class="comment"> * DatatypeValidatorFactory: IDDTV enabled</span>
00107 <span class="comment"> * XMLString:isValidName(): to validate Name (XML [4][5])</span>
00108 <span class="comment"> *</span>
00109 <span class="comment"> * Revision 1.23  2001/06/13 14:07:55  peiyongz</span>
00110 <span class="comment"> * isValidaEncName() to validate an encoding name (EncName)</span>
00111 <span class="comment"> *</span>
00112 <span class="comment"> * Revision 1.22  2001/05/23 15:44:51  tng</span>
00113 <span class="comment"> * Schema: NormalizedString fix.  By Pei Yong Zhang.</span>
00114 <span class="comment"> *</span>
00115 <span class="comment"> * Revision 1.21  2001/05/11 13:26:31  tng</span>
00116 <span class="comment"> * Copyright update.</span>
00117 <span class="comment"> *</span>
00118 <span class="comment"> * Revision 1.20  2001/05/09 18:43:30  tng</span>
00119 <span class="comment"> * Add StringDatatypeValidator and BooleanDatatypeValidator.  By Pei Yong Zhang.</span>
00120 <span class="comment"> *</span>
00121 <span class="comment"> * Revision 1.19  2001/05/03 20:34:35  tng</span>
00122 <span class="comment"> * Schema: SchemaValidator update</span>
00123 <span class="comment"> *</span>
00124 <span class="comment"> * Revision 1.18  2001/05/03 19:17:35  knoaman</span>
00125 <span class="comment"> * TraverseSchema Part II.</span>
00126 <span class="comment"> *</span>
00127 <span class="comment"> * Revision 1.17  2001/03/21 21:56:13  tng</span>
00128 <span class="comment"> * Schema: Add Schema Grammar, Schema Validator, and split the DTDValidator into DTDValidator, DTDScanner, and DTDGrammar.</span>
00129 <span class="comment"> *</span>
00130 <span class="comment"> * Revision 1.16  2001/03/02 20:52:46  knoaman</span>
00131 <span class="comment"> * Schema: Regular expression - misc. updates for error messages,</span>
00132 <span class="comment"> * and additions of new functions to XMLString class.</span>
00133 <span class="comment"> *</span>
00134 <span class="comment"> * Revision 1.15  2001/01/15 21:26:34  tng</span>
00135 <span class="comment"> * Performance Patches by David Bertoni.</span>
00136 <span class="comment"> *</span>
00137 <span class="comment"> * Details: (see xerces-c-dev mailing Jan 14)</span>
00138 <span class="comment"> * XMLRecognizer.cpp: the internal encoding string XMLUni::fgXMLChEncodingString</span>
00139 <span class="comment"> * was going through this function numerous times.  As a result, the top hot-spot</span>
00140 <span class="comment"> * for the parse was _wcsicmp().  The real problem is that the Microsofts wide string</span>
00141 <span class="comment"> * functions are unbelievably slow.  For things like encodings, it might be</span>
00142 <span class="comment"> * better to use a special comparison function that only considers a-z and</span>
00143 <span class="comment"> * A-Z as characters with case.  This works since the character set for</span>
00144 <span class="comment"> * encodings is limit to printable ASCII characters.</span>
00145 <span class="comment"> *</span>
00146 <span class="comment"> *  XMLScanner2.cpp: This also has some case-sensitive vs. insensitive compares.</span>
00147 <span class="comment"> * They are also much faster.  The other tweak is to only make a copy of an attribute</span>
00148 <span class="comment"> * string if it needs to be split.  And then, the strategy is to try to use a</span>
00149 <span class="comment"> * stack-based buffer, rather than a dynamically-allocated one.</span>
00150 <span class="comment"> *</span>
00151 <span class="comment"> * SAX2XMLReaderImpl.cpp: Again, more case-sensitive vs. insensitive comparisons.</span>
00152 <span class="comment"> *</span>
00153 <span class="comment"> * KVStringPair.cpp &amp; hpp: By storing the size of the allocation, the storage can</span>
00154 <span class="comment"> * likely be re-used many times, cutting down on dynamic memory allocations.</span>
00155 <span class="comment"> *</span>
00156 <span class="comment"> * XMLString.hpp: a more efficient implementation of stringLen().</span>
00157 <span class="comment"> *</span>
00158 <span class="comment"> * DTDValidator.cpp: another case of using a stack-based buffer when possible</span>
00159 <span class="comment"> *</span>
00160 <span class="comment"> * These patches made a big difference in parse time in some of our test</span>
00161 <span class="comment"> * files, especially the ones are very attribute-heavy.</span>
00162 <span class="comment"> *</span>
00163 <span class="comment"> * Revision 1.14  2000/10/13 22:47:57  andyh</span>
00164 <span class="comment"> * Fix bug (failure to null-terminate result) in XMLString::trim().</span>
00165 <span class="comment"> * Patch contributed by Nadav Aharoni</span>
00166 <span class="comment"> *</span>
00167 <span class="comment"> * Revision 1.13  2000/04/12 18:42:15  roddey</span>
00168 <span class="comment"> * Improved docs in terms of what 'max chars' means in the method</span>
00169 <span class="comment"> * parameters.</span>
00170 <span class="comment"> *</span>
00171 <span class="comment"> * Revision 1.12  2000/04/06 19:42:51  rahulj</span>
00172 <span class="comment"> * Clarified how big the target buffer should be in the API</span>
00173 <span class="comment"> * documentation.</span>
00174 <span class="comment"> *</span>
00175 <span class="comment"> * Revision 1.11  2000/03/23 01:02:38  roddey</span>
00176 <span class="comment"> * Updates to the XMLURL class to correct a lot of parsing problems</span>
00177 <span class="comment"> * and to add support for the port number. Updated the URL tests</span>
00178 <span class="comment"> * to test some of this new stuff.</span>
00179 <span class="comment"> *</span>
00180 <span class="comment"> * Revision 1.10  2000/03/20 23:00:46  rahulj</span>
00181 <span class="comment"> * Moved the inline definition of stringLen before the first</span>
00182 <span class="comment"> * use. This satisfied the HP CC compiler.</span>
00183 <span class="comment"> *</span>
00184 <span class="comment"> * Revision 1.9  2000/03/02 19:54:49  roddey</span>
00185 <span class="comment"> * This checkin includes many changes done while waiting for the</span>
00186 <span class="comment"> * 1.1.0 code to be finished. I can't list them all here, but a list is</span>
00187 <span class="comment"> * available elsewhere.</span>
00188 <span class="comment"> *</span>
00189 <span class="comment"> * Revision 1.8  2000/02/24 20:05:26  abagchi</span>
00190 <span class="comment"> * Swat for removing Log from API docs</span>
00191 <span class="comment"> *</span>
00192 <span class="comment"> * Revision 1.7  2000/02/16 18:51:52  roddey</span>
00193 <span class="comment"> * Fixed some facts in the docs and reformatted the docs to stay within</span>
00194 <span class="comment"> * a reasonable line width.</span>
00195 <span class="comment"> *</span>
00196 <span class="comment"> * Revision 1.6  2000/02/16 17:07:07  abagchi</span>
00197 <span class="comment"> * Added API docs</span>
00198 <span class="comment"> *</span>
00199 <span class="comment"> * Revision 1.5  2000/02/06 07:48:06  rahulj</span>
00200 <span class="comment"> * Year 2K copyright swat.</span>
00201 <span class="comment"> *</span>
00202 <span class="comment"> * Revision 1.4  2000/01/12 00:16:23  roddey</span>
00203 <span class="comment"> * Changes to deal with multiply nested, relative pathed, entities and to deal</span>
00204 <span class="comment"> * with the new URL class changes.</span>
00205 <span class="comment"> *</span>
00206 <span class="comment"> * Revision 1.3  1999/12/18 00:18:10  roddey</span>
00207 <span class="comment"> * More changes to support the new, completely orthagonal support for</span>
00208 <span class="comment"> * intrinsic encodings.</span>
00209 <span class="comment"> *</span>
00210 <span class="comment"> * Revision 1.2  1999/12/15 19:41:28  roddey</span>
00211 <span class="comment"> * Support for the new transcoder system, where even intrinsic encodings are</span>
00212 <span class="comment"> * done via the same transcoder abstraction as external ones.</span>
00213 <span class="comment"> *</span>
00214 <span class="comment"> * Revision 1.1.1.1  1999/11/09 01:05:52  twl</span>
00215 <span class="comment"> * Initial checkin</span>
00216 <span class="comment"> *</span>
00217 <span class="comment"> * Revision 1.2  1999/11/08 20:45:21  rahul</span>
00218 <span class="comment"> * Swat for adding in Product name and CVS comment log variable.</span>
00219 <span class="comment"> *</span>
00220 <span class="comment"> */</span>
00221 
00222 <span class="preprocessor">#if !defined(XMLSTRING_HPP)</span>
<a name="l00223"></a><a class="code" href="XMLString_8hpp.html#a0">00223</a> <span class="preprocessor"></span><span class="preprocessor">#define XMLSTRING_HPP</span>
00224 <span class="preprocessor"></span>
00225 <span class="preprocessor">#include &lt;xercesc/util/BaseRefVectorOf.hpp&gt;</span>
00226 
00227 <a class="code" href="XercesDefs_8hpp.html#a2">XERCES_CPP_NAMESPACE_BEGIN</a>
00228 
<a name="l00229"></a><a class="code" href="XMLString_8hpp.html#a1">00229</a> <span class="keyword">class </span><a class="code" href="classXMLLCPTranscoder.html">XMLLCPTranscoder</a>;
<a name="l00241"></a><a class="code" href="classXMLString.html">00241</a> <span class="keyword">class </span><a class="code" href="XercesDefs_8hpp.html#a6"></a> <a class="code" href="classXMLString.html">XMLString</a>
00242 {
00243 <span class="keyword">public</span>:
00244     <span class="comment">/* Static methods for native character mode string manipulation */</span>
00245 
00246 
00263     <span class="keyword">static</span> <span class="keywordtype">void</span> catString
00264     (
00265                 <span class="keywordtype">char</span>* <span class="keyword">const</span>     target
00266         , <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span>     src
00267     );
00268 
00281     <span class="keyword">static</span> <span class="keywordtype">void</span> catString
00282     (
00283                 XMLCh* <span class="keyword">const</span>    target
00284         , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    src
00285     );
00287 
00301     <span class="keyword">static</span> <span class="keywordtype">int</span> compareIString
00302     (
00303         <span class="keyword">const</span>   <span class="keywordtype">char</span>* <span class="keyword">const</span>     str1
00304         , <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span>     str2
00305     );
00306 
00317     <span class="keyword">static</span> <span class="keywordtype">int</span> compareIString
00318     (
00319         <span class="keyword">const</span>   XMLCh* <span class="keyword">const</span>    str1
00320         , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    str2
00321     );
00322 
00323 
00337     <span class="keyword">static</span> <span class="keywordtype">int</span> compareNString
00338     (
00339         <span class="keyword">const</span>   <span class="keywordtype">char</span>* <span class="keyword">const</span>     str1
00340         , <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span>     str2
00341         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    count
00342     );
00343 
00357     <span class="keyword">static</span> <span class="keywordtype">int</span> compareNString
00358     (
00359         <span class="keyword">const</span>   XMLCh* <span class="keyword">const</span>    str1
00360         , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    str2
00361         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    count
00362     );
00363 
00364 
00378     <span class="keyword">static</span> <span class="keywordtype">int</span> compareNIString
00379     (
00380         <span class="keyword">const</span>   <span class="keywordtype">char</span>* <span class="keyword">const</span>     str1
00381         , <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span>     str2
00382         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    count
00383     );
00384 
00399     <span class="keyword">static</span> <span class="keywordtype">int</span> compareNIString
00400     (
00401         <span class="keyword">const</span>   XMLCh* <span class="keyword">const</span>    str1
00402         , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    str2
00403         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    count
00404     );
00405 
00418     <span class="keyword">static</span> <span class="keywordtype">int</span> compareString
00419     (
00420         <span class="keyword">const</span>   <span class="keywordtype">char</span>* <span class="keyword">const</span>     str1
00421         , <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span>     str2
00422     );
00423 
00435     <span class="keyword">static</span> <span class="keywordtype">int</span> compareString
00436     (
00437         <span class="keyword">const</span>   XMLCh* <span class="keyword">const</span>    str1
00438         , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    str2
00439     );
00440 
00449     <span class="keyword">static</span> <span class="keywordtype">bool</span> equals
00450     (
00451           <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    str1
00452         , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    str2
00453     );
00454 
00455     <span class="keyword">static</span> <span class="keywordtype">bool</span> equals
00456     (
00457           <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span>    str1
00458         , <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span>    str2
00459     );
00460 
00487     <span class="keyword">static</span> <span class="keywordtype">bool</span> regionMatches
00488     (
00489         <span class="keyword">const</span>   XMLCh* <span class="keyword">const</span>    str1
00490         , <span class="keyword">const</span> <span class="keywordtype">int</span>             offset1
00491         , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    str2
00492         , <span class="keyword">const</span> <span class="keywordtype">int</span>             offset2
00493         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    charCount
00494     );
00495 
00523     <span class="keyword">static</span> <span class="keywordtype">bool</span> regionIMatches
00524     (
00525         <span class="keyword">const</span>   XMLCh* <span class="keyword">const</span>    str1
00526         , <span class="keyword">const</span> <span class="keywordtype">int</span>             offset1
00527         , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    str2
00528         , <span class="keyword">const</span> <span class="keywordtype">int</span>             offset2
00529         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    charCount
00530     );
00532 
00545     <span class="keyword">static</span> <span class="keywordtype">void</span> copyString
00546     (
00547                 <span class="keywordtype">char</span>* <span class="keyword">const</span>     target
00548         , <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span>     src
00549     );
00550 
00561     <span class="keyword">static</span> <span class="keywordtype">void</span> copyString
00562     (
00563                 XMLCh* <span class="keyword">const</span>    target
00564         , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    src
00565     );
00566 
00579     <span class="keyword">static</span> <span class="keywordtype">bool</span> copyNString
00580     (
00581                 XMLCh* <span class="keyword">const</span>    target
00582         , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    src
00583         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    maxChars
00584     );
00586 
00595     <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash
00596     (
00597         <span class="keyword">const</span>   <span class="keywordtype">char</span>* <span class="keyword">const</span>     toHash
00598         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    hashModulus
00599     );
00600 
00607     <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hash
00608     (
00609         <span class="keyword">const</span>   XMLCh* <span class="keyword">const</span>    toHash
00610         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    hashModulus
00611     );
00612 
00622     <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> hashN
00623     (
00624         <span class="keyword">const</span>   XMLCh* <span class="keyword">const</span>    toHash
00625         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    numChars
00626         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    hashModulus
00627     );
00628 
00630 
00641     <span class="keyword">static</span> <span class="keywordtype">int</span> indexOf(<span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> toSearch, <span class="keyword">const</span> <span class="keywordtype">char</span> ch);
00642 
00651     <span class="keyword">static</span> <span class="keywordtype">int</span> indexOf(<span class="keyword">const</span> XMLCh* <span class="keyword">const</span> toSearch, <span class="keyword">const</span> XMLCh ch);
00652 
00663     <span class="keyword">static</span> <span class="keywordtype">int</span> indexOf
00664     (
00665         <span class="keyword">const</span>   <span class="keywordtype">char</span>* <span class="keyword">const</span>     toSearch
00666         , <span class="keyword">const</span> <span class="keywordtype">char</span>            chToFind
00667         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    fromIndex
00668     );
00669 
00680     <span class="keyword">static</span> <span class="keywordtype">int</span> indexOf
00681     (
00682         <span class="keyword">const</span>   XMLCh* <span class="keyword">const</span>    toSearch
00683         , <span class="keyword">const</span> XMLCh           chToFind
00684         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    fromIndex
00685     );
00686 
00695     <span class="keyword">static</span> <span class="keywordtype">int</span> lastIndexOf(<span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> toSearch, <span class="keyword">const</span> <span class="keywordtype">char</span> ch);
00696 
00705     <span class="keyword">static</span> <span class="keywordtype">int</span> lastIndexOf(<span class="keyword">const</span> XMLCh* <span class="keyword">const</span> toSearch, <span class="keyword">const</span> XMLCh ch);
00706 
00717     <span class="keyword">static</span> <span class="keywordtype">int</span> lastIndexOf
00718     (
00719         <span class="keyword">const</span>   <span class="keywordtype">char</span>* <span class="keyword">const</span>     toSearch
00720         , <span class="keyword">const</span> <span class="keywordtype">char</span>            chToFind
00721         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    fromIndex
00722     );
00723 
00734     <span class="keyword">static</span> <span class="keywordtype">int</span> lastIndexOf
00735     (
00736         <span class="keyword">const</span>   XMLCh* <span class="keyword">const</span>    toSearch
00737         , <span class="keyword">const</span> XMLCh           ch
00738         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    fromIndex
00739     );
00741 
00749     <span class="keyword">static</span> <span class="keywordtype">void</span> moveChars
00750     (
00751                 XMLCh* <span class="keyword">const</span>    targetStr
00752         , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    srcStr
00753         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    count
00754     );
00755 
00757 
00768     <span class="keyword">static</span> <span class="keywordtype">void</span> subString
00769     (
00770                 <span class="keywordtype">char</span>* <span class="keyword">const</span>    targetStr
00771         , <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span>    srcStr
00772         , <span class="keyword">const</span> <span class="keywordtype">int</span>            startIndex
00773         , <span class="keyword">const</span> <span class="keywordtype">int</span>            endIndex
00774     );
00775 
00784     <span class="keyword">static</span> <span class="keywordtype">void</span> subString
00785     (
00786                 XMLCh* <span class="keyword">const</span>    targetStr
00787         , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    srcStr
00788         , <span class="keyword">const</span> <span class="keywordtype">int</span>             startIndex
00789         , <span class="keyword">const</span> <span class="keywordtype">int</span>             endIndex
00790     );
00791 
00793 
00805     <span class="keyword">static</span> <span class="keywordtype">char</span>* replicate(<span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> toRep);
00806 
00816     <span class="keyword">static</span> XMLCh* replicate(<span class="keyword">const</span> XMLCh* <span class="keyword">const</span> toRep);
00817 
00819 
00828     <span class="keyword">static</span> <span class="keywordtype">bool</span> startsWith
00829     (
00830         <span class="keyword">const</span>   <span class="keywordtype">char</span>* <span class="keyword">const</span>     toTest
00831         , <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span>     prefix
00832     );
00833 
00840     <span class="keyword">static</span> <span class="keywordtype">bool</span> startsWith
00841     (
00842         <span class="keyword">const</span>   XMLCh* <span class="keyword">const</span>    toTest
00843         , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    prefix
00844     );
00845 
00854     <span class="keyword">static</span> <span class="keywordtype">bool</span> startsWithI
00855     (
00856         <span class="keyword">const</span>   <span class="keywordtype">char</span>* <span class="keyword">const</span>     toTest
00857         , <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span>     prefix
00858     );
00859 
00869     <span class="keyword">static</span> <span class="keywordtype">bool</span> startsWithI
00870     (
00871         <span class="keyword">const</span>   XMLCh* <span class="keyword">const</span>    toTest
00872         , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    prefix
00873     );
00874 
00881     <span class="keyword">static</span> <span class="keywordtype">bool</span> endsWith
00882     (
00883         <span class="keyword">const</span>   XMLCh* <span class="keyword">const</span>    toTest
00884         , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    suffix
00885     );
00886 
00887 
00894     <span class="keyword">static</span> <span class="keyword">const</span> XMLCh* findAny
00895     (
00896         <span class="keyword">const</span>   XMLCh* <span class="keyword">const</span>    toSearch
00897         , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    searchList
00898     );
00899 
00906     <span class="keyword">static</span> XMLCh* findAny
00907     (
00908                 XMLCh* <span class="keyword">const</span>    toSearch
00909         , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    searchList
00910     );
00911 
00918     <span class="keyword">static</span> <span class="keywordtype">int</span> patternMatch
00919     (
00920           <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    toSearch
00921         , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    pattern
00922     );
00923 
00928     <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stringLen(<span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span> src);
00929 
00934     <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> stringLen(<span class="keyword">const</span> XMLCh* <span class="keyword">const</span> src);
00935 
00943     <span class="keyword">static</span> <span class="keywordtype">bool</span> isValidNCName(<span class="keyword">const</span> XMLCh* <span class="keyword">const</span> name);
00944 
00952     <span class="keyword">static</span> <span class="keywordtype">bool</span> isValidName(<span class="keyword">const</span> XMLCh* <span class="keyword">const</span> name);
00953 
00959     <span class="keyword">static</span> <span class="keywordtype">bool</span> isValidEncName(<span class="keyword">const</span> XMLCh* <span class="keyword">const</span> name);
00960 
00968     <span class="keyword">static</span> <span class="keywordtype">bool</span> isValidQName(<span class="keyword">const</span> XMLCh* <span class="keyword">const</span> name);
00969 
00976     <span class="keyword">static</span> <span class="keywordtype">bool</span> isAlpha(XMLCh <span class="keyword">const</span> theChar);
00977 
00983     <span class="keyword">static</span> <span class="keywordtype">bool</span> isDigit(XMLCh <span class="keyword">const</span> theChar);
00984 
00990     <span class="keyword">static</span> <span class="keywordtype">bool</span> isAlphaNum(XMLCh <span class="keyword">const</span> theChar);
00991 
00997     <span class="keyword">static</span> <span class="keywordtype">bool</span> isHex(XMLCh <span class="keyword">const</span> theChar);
00998 
01006     <span class="keyword">static</span> <span class="keywordtype">bool</span> isAllWhiteSpace(<span class="keyword">const</span> XMLCh* <span class="keyword">const</span> toCheck);
01007 
01013     <span class="keyword">static</span> <span class="keywordtype">bool</span> isInList(<span class="keyword">const</span> XMLCh* <span class="keyword">const</span> toFind, <span class="keyword">const</span> XMLCh* <span class="keyword">const</span> enumList);
01014 
01016 
01019 
01030     <span class="keyword">static</span> <span class="keywordtype">void</span> binToText
01031     (
01032         <span class="keyword">const</span>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    toFormat
01033         ,       <span class="keywordtype">char</span>* <span class="keyword">const</span>     toFill
01034         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    maxChars
01035         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    radix
01036     );
01037 
01048     <span class="keyword">static</span> <span class="keywordtype">void</span> binToText
01049     (
01050         <span class="keyword">const</span>   <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    toFormat
01051         ,       XMLCh* <span class="keyword">const</span>    toFill
01052         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    maxChars
01053         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    radix
01054     );
01055 
01066     <span class="keyword">static</span> <span class="keywordtype">void</span> binToText
01067     (
01068         <span class="keyword">const</span>   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>   toFormat
01069         ,       <span class="keywordtype">char</span>* <span class="keyword">const</span>     toFill
01070         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    maxChars
01071         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    radix
01072     );
01073 
01084     <span class="keyword">static</span> <span class="keywordtype">void</span> binToText
01085     (
01086         <span class="keyword">const</span>   <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>   toFormat
01087         ,       XMLCh* <span class="keyword">const</span>    toFill
01088         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    maxChars
01089         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    radix
01090     );
01091 
01102     <span class="keyword">static</span> <span class="keywordtype">void</span> binToText
01103     (
01104         <span class="keyword">const</span>   <span class="keywordtype">long</span>            toFormat
01105         ,       <span class="keywordtype">char</span>* <span class="keyword">const</span>     toFill
01106         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    maxChars
01107         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    radix
01108     );
01109 
01120     <span class="keyword">static</span> <span class="keywordtype">void</span> binToText
01121     (
01122         <span class="keyword">const</span>   <span class="keywordtype">long</span>            toFormat
01123         ,       XMLCh* <span class="keyword">const</span>    toFill
01124         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    maxChars
01125         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    radix
01126     );
01127 
01138     <span class="keyword">static</span> <span class="keywordtype">void</span> binToText
01139     (
01140         <span class="keyword">const</span>   <span class="keywordtype">int</span>             toFormat
01141         ,       <span class="keywordtype">char</span>* <span class="keyword">const</span>     toFill
01142         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    maxChars
01143         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    radix
01144     );
01145 
01156     <span class="keyword">static</span> <span class="keywordtype">void</span> binToText
01157     (
01158         <span class="keyword">const</span>   <span class="keywordtype">int</span>             toFormat
01159         ,       XMLCh* <span class="keyword">const</span>    toFill
01160         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    maxChars
01161         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    radix
01162     );
01163 
01174     <span class="keyword">static</span> <span class="keywordtype">bool</span> textToBin
01175     (
01176         <span class="keyword">const</span>   XMLCh* <span class="keyword">const</span>    toConvert
01177         ,       <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&amp;   toFill
01178     );
01179 
01192     <span class="keyword">static</span> <span class="keywordtype">int</span> parseInt
01193     (
01194         <span class="keyword">const</span>   XMLCh* <span class="keyword">const</span>    toConvert
01195     );
01196 
01202     <span class="keyword">static</span> <span class="keywordtype">void</span> cut
01203     (
01204                 XMLCh* <span class="keyword">const</span>    toCutFrom
01205         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    count
01206     );
01207 
01218     <span class="keyword">static</span> <span class="keywordtype">char</span>* transcode
01219     (
01220         <span class="keyword">const</span>   XMLCh* <span class="keyword">const</span>    toTranscode
01221     );
01222 
01239     <span class="keyword">static</span> <span class="keywordtype">bool</span> transcode
01240     (
01241         <span class="keyword">const</span>   XMLCh* <span class="keyword">const</span>    toTranscode
01242         ,       <span class="keywordtype">char</span>* <span class="keyword">const</span>     toFill
01243         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    maxChars
01244     );
01245 
01256     <span class="keyword">static</span> XMLCh* transcode
01257     (
01258         <span class="keyword">const</span>   <span class="keywordtype">char</span>* <span class="keyword">const</span>     toTranscode
01259     );
01260 
01272     <span class="keyword">static</span> <span class="keywordtype">bool</span> transcode
01273     (
01274         <span class="keyword">const</span>   <span class="keywordtype">char</span>* <span class="keyword">const</span>     toTranscode
01275         ,       XMLCh* <span class="keyword">const</span>    toFill
01276         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    maxChars
01277     );
01278 
01284     <span class="keyword">static</span> <span class="keywordtype">void</span> trim(<span class="keywordtype">char</span>* <span class="keyword">const</span> toTrim);
01285 
01291     <span class="keyword">static</span> <span class="keywordtype">void</span> trim(XMLCh* <span class="keyword">const</span> toTrim);
01292 
01299     <span class="keyword">static</span> BaseRefVectorOf&lt;XMLCh&gt;* tokenizeString(<span class="keyword">const</span> XMLCh* <span class="keyword">const</span> tokenizeSrc);
01300 
01302 
01313     <span class="keyword">static</span> XMLCh* makeUName
01314     (
01315         <span class="keyword">const</span>   XMLCh* <span class="keyword">const</span>    pszURI
01316         , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    pszName
01317     );
01318 
01334     <span class="keyword">static</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> replaceTokens
01335     (
01336                 XMLCh* <span class="keyword">const</span>    errText
01337         , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    maxChars
01338         , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    text1
01339         , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    text2
01340         , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    text3
01341         , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    text4
01342     );
01343 
01348     <span class="keyword">static</span> <span class="keywordtype">void</span> upperCase(XMLCh* <span class="keyword">const</span> toUpperCase);
01349 
01354     <span class="keyword">static</span> <span class="keywordtype">void</span> lowerCase(XMLCh* <span class="keyword">const</span> toLowerCase);
01355 
01359     <span class="keyword">static</span> <span class="keywordtype">bool</span> isWSReplaced(<span class="keyword">const</span> XMLCh* <span class="keyword">const</span> toCheck);
01360 
01364     <span class="keyword">static</span> <span class="keywordtype">bool</span> isWSCollapsed(<span class="keyword">const</span> XMLCh* <span class="keyword">const</span> toCheck);
01365 
01370     <span class="keyword">static</span> <span class="keywordtype">void</span> replaceWS(XMLCh* <span class="keyword">const</span> toConvert);
01371 
01376     <span class="keyword">static</span> <span class="keywordtype">void</span> collapseWS(XMLCh* <span class="keyword">const</span> toConvert);
01377 
01382     <span class="keyword">static</span> <span class="keywordtype">void</span> removeWS(XMLCh* <span class="keyword">const</span> toConvert);
01383 
01391     <span class="keyword">static</span> <span class="keywordtype">void</span> fixURI(<span class="keyword">const</span> XMLCh* <span class="keyword">const</span> str, XMLCh* <span class="keyword">const</span> target);
01392 
01394 
01402     <span class="keyword">static</span> <span class="keywordtype">void</span> release(<span class="keywordtype">char</span>** buf);
01403 
01410     <span class="keyword">static</span> <span class="keywordtype">void</span> release(XMLCh** buf);
01411 
01418     <span class="keyword">static</span> <span class="keywordtype">void</span> release(<a class="code" href="XercesDefs_8hpp.html#a13">XMLByte</a>** buf);
01419 
01421 
01422 
01423 <span class="keyword">private</span> :
01424 
01428     <a class="code" href="classXMLString.html">XMLString</a>();
01430     ~<a class="code" href="classXMLString.html">XMLString</a>();
01432 
01433 
01437     <span class="keyword">static</span> <span class="keywordtype">void</span> initString(<a class="code" href="classXMLLCPTranscoder.html">XMLLCPTranscoder</a>* <span class="keyword">const</span> defToUse);
01438     <span class="keyword">static</span> <span class="keywordtype">void</span> termString();
01440 
01445     <span class="keyword">static</span> <span class="keywordtype">bool</span> validateRegion(<span class="keyword">const</span> XMLCh* <span class="keyword">const</span> str1, <span class="keyword">const</span> <span class="keywordtype">int</span> offset1,
01446                         <span class="keyword">const</span> XMLCh* <span class="keyword">const</span> str2, <span class="keyword">const</span> <span class="keywordtype">int</span> offset2,
01447                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> charCount);
01448 
<a name="l01449"></a><a class="code" href="classXMLString.html#l0">01449</a>     <span class="keyword">friend</span> <span class="keyword">class </span><a class="code" href="classXMLPlatformUtils.html">XMLPlatformUtils</a>;
01450 };
01451 
01452 
01453 <span class="comment">// ---------------------------------------------------------------------------</span>
01454 <span class="comment">//  Inline some methods that are either just passthroughs to other string</span>
01455 <span class="comment">//  methods, or which are key for performance.</span>
01456 <span class="comment">// ---------------------------------------------------------------------------</span>
<a name="l01457"></a><a class="code" href="classXMLString.html#z591_0">01457</a> <span class="keyword">inline</span> <span class="keywordtype">void</span> <a class="code" href="classXMLString.html#z591_0">XMLString::moveChars</a>(       XMLCh* <span class="keyword">const</span>    targetStr
01458                                 , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    srcStr
01459                                 , <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>    count)
01460 {
01461     XMLCh* outPtr = targetStr;
01462     <span class="keyword">const</span> XMLCh* inPtr = srcStr;
01463     <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = 0; index &lt; count; index++)
01464         *outPtr++ = *inPtr++;
01465 }
01466 
<a name="l01467"></a><a class="code" href="classXMLString.html#z597_9">01467</a> <span class="keyword">inline</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classXMLString.html#z597_8">XMLString::stringLen</a>(<span class="keyword">const</span> XMLCh* <span class="keyword">const</span> src)
01468 {
01469     <span class="keywordflow">if</span> (src == 0 || *src == 0)
01470     {
01471         <span class="keywordflow">return</span> 0;
01472    }
01473     <span class="keywordflow">else</span>
01474    {
01475         <span class="keyword">const</span> XMLCh* pszTmp = src + 1;
01476 
01477         <span class="keywordflow">while</span> (*pszTmp)
01478             ++pszTmp;
01479 
01480         <span class="keywordflow">return</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>)(pszTmp - src);
01481     }
01482 }
01483 
<a name="l01484"></a><a class="code" href="classXMLString.html#z597_1">01484</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classXMLString.html#z597_0">XMLString::startsWith</a>(  <span class="keyword">const</span>   XMLCh* <span class="keyword">const</span>    toTest
01485                                     , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    prefix)
01486 {
01487     <span class="keywordflow">return</span> (<a class="code" href="classXMLString.html#z583_2">compareNString</a>(toTest, prefix, <a class="code" href="classXMLString.html#z597_8">stringLen</a>(prefix)) == 0);
01488 }
01489 
<a name="l01490"></a><a class="code" href="classXMLString.html#z597_3">01490</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classXMLString.html#z597_2">XMLString::startsWithI</a>( <span class="keyword">const</span>   XMLCh* <span class="keyword">const</span>    toTest
01491                                     , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    prefix)
01492 {
01493     <span class="keywordflow">return</span> (<a class="code" href="classXMLString.html#z583_4">compareNIString</a>(toTest, prefix, <a class="code" href="classXMLString.html#z597_8">stringLen</a>(prefix)) == 0);
01494 }
01495 
<a name="l01496"></a><a class="code" href="classXMLString.html#z597_4">01496</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classXMLString.html#z597_4">XMLString::endsWith</a>(<span class="keyword">const</span> XMLCh* <span class="keyword">const</span> toTest,
01497                                 <span class="keyword">const</span> XMLCh* <span class="keyword">const</span> suffix)
01498 {
01499 
01500     <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> suffixLen = <a class="code" href="classXMLString.html#z597_8">XMLString::stringLen</a>(suffix);
01501 
01502     <span class="keywordflow">return</span> <a class="code" href="classXMLString.html#z583_10">regionMatches</a>(toTest, <a class="code" href="classXMLString.html#z597_8">XMLString::stringLen</a>(toTest) - suffixLen,
01503                          suffix, 0, suffixLen);
01504 }
01505 
<a name="l01506"></a><a class="code" href="classXMLString.html#z595_1">01506</a> <span class="keyword">inline</span> XMLCh* <a class="code" href="classXMLString.html#z595_0">XMLString::replicate</a>(<span class="keyword">const</span> XMLCh* <span class="keyword">const</span> toRep)
01507 {
01508     <span class="comment">// If a null string, return a null string!</span>
01509     XMLCh* ret = 0;
01510     <span class="keywordflow">if</span> (toRep)
01511     {
01512         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> len = <a class="code" href="classXMLString.html#z597_8">stringLen</a>(toRep);
01513         ret = <span class="keyword">new</span> XMLCh[len + 1];
01514         XMLCh* outPtr = ret;
01515         <span class="keyword">const</span> XMLCh* inPtr = toRep;
01516         <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> index = 0; index &lt;= len; index++)
01517             *outPtr++ = *inPtr++;
01518     }
01519     <span class="keywordflow">return</span> ret;
01520 }
01521 
01522 <span class="keyword">inline</span> <span class="keywordtype">bool</span> XMLString::validateRegion(<span class="keyword">const</span> XMLCh* <span class="keyword">const</span> str1,
01523                                       <span class="keyword">const</span> <span class="keywordtype">int</span> offset1,
01524                                       <span class="keyword">const</span> XMLCh* <span class="keyword">const</span> str2,
01525                                       <span class="keyword">const</span> <span class="keywordtype">int</span> offset2,
01526                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> charCount)
01527 {
01528 
01529     <span class="keywordflow">if</span> (offset1 &lt; 0 || offset2 &lt; 0 ||
01530         (offset1 + charCount) &gt; <a class="code" href="classXMLString.html#z597_8">XMLString::stringLen</a>(str1) ||
01531         (offset2 + charCount) &gt; <a class="code" href="classXMLString.html#z597_8">XMLString::stringLen</a>(str2) )
01532         <span class="keywordflow">return</span> <span class="keyword">false</span>;
01533 
01534     <span class="keywordflow">return</span> <span class="keyword">true</span>;
01535 }
01536 
<a name="l01537"></a><a class="code" href="classXMLString.html#z583_8">01537</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classXMLString.html#z583_8">XMLString::equals</a>(   <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    str1
01538                                , <span class="keyword">const</span> XMLCh* <span class="keyword">const</span>    str2)
01539 {
01540     <span class="keyword">const</span> XMLCh* psz1 = str1;
01541     <span class="keyword">const</span> XMLCh* psz2 = str2;
01542 
01543     <span class="keywordflow">if</span> (psz1 == 0 || psz2 == 0) {
01544         <span class="keywordflow">if</span> ((psz1 != 0 &amp;&amp; *psz1) || (psz2 != 0 &amp;&amp; *psz2))
01545             <span class="keywordflow">return</span> <span class="keyword">false</span>;
01546         <span class="keywordflow">else</span>
01547             <span class="keywordflow">return</span> <span class="keyword">true</span>;
01548     }
01549 
01550     <span class="keywordflow">while</span> (*psz1 == *psz2)
01551     {
01552         <span class="comment">// If either has ended, then they both ended, so equal</span>
01553         <span class="keywordflow">if</span> (!*psz1)
01554             <span class="keywordflow">return</span> <span class="keyword">true</span>;
01555 
01556         <span class="comment">// Move upwards for the next round</span>
01557         psz1++;
01558         psz2++;
01559     }
01560     <span class="keywordflow">return</span> <span class="keyword">false</span>;
01561 }
01562 
<a name="l01563"></a><a class="code" href="classXMLString.html#z583_9">01563</a> <span class="keyword">inline</span> <span class="keywordtype">bool</span> <a class="code" href="classXMLString.html#z583_8">XMLString::equals</a>(   <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span>    str1
01564                                , <span class="keyword">const</span> <span class="keywordtype">char</span>* <span class="keyword">const</span>    str2)
01565 {
01566     <span class="keyword">const</span> <span class="keywordtype">char</span>* psz1 = str1;
01567     <span class="keyword">const</span> <span class="keywordtype">char</span>* psz2 = str2;
01568 
01569     <span class="keywordflow">if</span> (psz1 == 0 || psz2 == 0) {
01570         <span class="keywordflow">if</span> ((psz1 != 0 &amp;&amp; *psz1) || (psz2 != 0 &amp;&amp; *psz2))
01571             <span class="keywordflow">return</span> <span class="keyword">false</span>;
01572         <span class="keywordflow">else</span>
01573             <span class="keywordflow">return</span> <span class="keyword">true</span>;
01574     }
01575 
01576     <span class="keywordflow">while</span> (*psz1 == *psz2)
01577     {
01578         <span class="comment">// If either has ended, then they both ended, so equal</span>
01579         <span class="keywordflow">if</span> (!*psz1)
01580             <span class="keywordflow">return</span> <span class="keyword">true</span>;
01581 
01582         <span class="comment">// Move upwards for the next round</span>
01583         psz1++;
01584         psz2++;
01585     }
01586     <span class="keywordflow">return</span> <span class="keyword">false</span>;
01587 }
01588 
01589 <a class="code" href="XercesDefs_8hpp.html#a3">XERCES_CPP_NAMESPACE_END</a>
01590 
01591 <span class="preprocessor">#endif</span>
</pre></div>    </FONT></TD></TR></TABLE><BR>
</TD></TR></TABLE></TD></TR></TABLE><BR><TABLE border="0" cellpadding="0" cellspacing="0" width="620"><TR><TD bgcolor="#0086b2"><IMG height="1" src="images/dot.gif" width="1" alt=""></TD></TR><TR><TD align="center"><FONT color="#0086b2" size="-1"><I>
              Copyright &copy; 2000 The Apache Software Foundation.
              All Rights Reserved.
            </I></FONT></TD></TR></TABLE></BODY></HTML>
